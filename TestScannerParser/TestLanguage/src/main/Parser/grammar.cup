import java_cup.runtime.*;
import lab7.*;
import java.io.FileWriter;
import java.io.IOException;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

action code {:

   public JSONArray allNodes = new JSONArray();
   public JSONArray allNodesUnderProg = new JSONArray();



   class BinaryOPNode extends AbstractNode {
         NumberNode number1;
         NumberNode number2;
         String operator;
         JSONObject BinaryNode = new JSONObject();

         public BinaryOPNode (NumberNode number1, NumberNode number2, String operator) {
            this.number1 = number1;
            this.number2 = number2;
            this.operator = operator;

            BinaryNode.put("type", "BinaryExpression");
            BinaryNode.put("operator", operator);
            BinaryNode.put("left", number1.node);
            BinaryNode.put("right", number2.node);

            allNodesUnderProg.add(BinaryNode);

         }
         public String getName() {return number1 + " " + operator + " " + number2;}
   }
   class NumberNode extends AbstractNode {
        int value;
        public JSONObject node = new JSONObject();

        public NumberNode(int value) {
            this.value = value;
            node.put("type", "Literal");
            node.put("value", value);

        }

        public int getValue() {return value;}
   }

   class SingleNode extends AbstractNode {
         String name;

         public SingleNode(String name) {
            this.name = name;
         }
         public String getName() {return name;}
   }

   public AbstractNode makeNode(NumberNode number1, NumberNode number2, String operator) {return new BinaryOPNode(number1,number2, operator);}
   public AbstractNode makeNode(int value) {return new NumberNode(value);}
   public AbstractNode makeNode(String name) {return new SingleNode(name);}
:};
/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, TIMES, DIVIDE, MOD;
terminal Integer    NUMBER;        // our scanner provides numbers as integers

non terminal AbstractNode CompilationUnit;
non terminal AbstractNode expr_list;
non terminal AbstractNode expr;      // used to store evaluated subexpressions

/* Precedences */
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
/* The grammar rules */

start with CompilationUnit;

CompilationUnit ::= expr_list:el
{:

    PrintTree printTree = new PrintTree(System.out);
    AbstractNode prog = makeNode("Program").adoptChildren(el);
    JSONObject progJSON = new JSONObject();
    progJSON.put("type", "Program");
    progJSON.put("body", allNodesUnderProg);
    prog.walkTree(printTree);
    allNodes.add(progJSON);

     try (FileWriter file = new FileWriter("ast.json")) {
                //We can write any JSONArray or JSONObject instance to the file
                file.write(allNodes.toJSONString());
                file.flush();

     } catch (IOException e) {
         e.printStackTrace();
     }
:};

expr_list ::= expr_list:es expr:e SEMI {:RESULT = es.makeSibling(e); :}
            | expr:e SEMI              {:RESULT = e; :}
	    	;
	    
expr      ::= expr:e1 PLUS  expr:e2
          {: RESULT = makeNode((NumberNode)e1, (NumberNode)e2, "+"); :}
	    	| expr:e1 MINUS expr:e2
	    	{: RESULT = makeNode((NumberNode)e1, (NumberNode)e2, "-"); :}
	    	| expr:e1 TIMES expr:e2
	    	{: RESULT = makeNode((NumberNode)e1, (NumberNode)e2, "*"); :}
	    	| expr:e1 DIVIDE expr:e2
            {: RESULT = makeNode((NumberNode)e1, (NumberNode)e2, "/"); :}
            | expr:e1 MOD expr:e2
            {: RESULT = makeNode((NumberNode)e1, (NumberNode)e2, "%"); :}
	    	| NUMBER:n
	    	{: RESULT = makeNode(n); :}
	    	| MINUS expr:e

            ;
