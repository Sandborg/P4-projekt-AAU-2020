import java_cup.runtime.*;
import lab7.*;
import AST.*;
import java.io.FileWriter;
import java.io.IOException;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

action code {:

   public JSONArray allNodes = new JSONArray();
   public JSONArray allNodesUnderProg = new JSONArray();
   public JSONArray expressions = new JSONArray();

   public AbstractNode prog;
      public AbstractNode addAllNodesToJSON (AbstractNode n, boolean addToList) {
                     if(n.getChild() != null) {
                         n.node.put("Body", AddAllChild(n.getChild(),new JSONArray()));
                         if(addToList) {
                             allNodes.add(n.node);
                         }
                     }
                     return null;
                 }

                 public JSONArray AddAllChild (AbstractNode n, JSONArray array) {
                     array.add(n.node);
                     if(n.getChild() != null)
                     {
                         addAllNodesToJSON(n,false);
                     }

                     if(n.getSib() != null) {
                         AddAllChild(n.getSib(),array);
                     }
                     return array;
                 }

   public AbstractNode makeNode(AbstractNode number1, AbstractNode number2, String operator) {return new BinaryOPNode(number1,number2, operator);}
   public AbstractNode makeNode(int value) {return new IntegerNode(value);}
   public AbstractNode makeNode(float value) {return new FloatNode(value);}
   public AbstractNode makeNode(AbstractNode type, AbstractNode id, AbstractNode body) {return new VariableDeclarationNode(type,id, body);}

   public AbstractNode makeVariableDeclarationNoBody(AbstractNode type, AbstractNode id) {return new VariableDeclarationNode(type,id);}
   public AbstractNode makeTypeNode(String type) {return new TypeNode(type);}
   public AbstractNode makeIdentifierNode(String id, String idType) {return new IdentifierNode(id, idType);}
   public AbstractNode makeAssignmentNode(AbstractNode set, AbstractNode to) {return new AssignmentNode(set,to);}
   public AbstractNode makeFunctionDecNode(AbstractNode type, AbstractNode id, AbstractNode parems) {return new FunctionDecNode(type,id,parems);}
   public AbstractNode makeFunctionDecNodeNoParams(AbstractNode type, AbstractNode id) {return new FunctionDecNode(type,id);}
   public AbstractNode makeFunctionDefNode(AbstractNode type, AbstractNode id, AbstractNode params, AbstractNode body) {return new FunctionDefNode(type,id,params,body);}
   public AbstractNode makeFunctionDefNodeNoBody(AbstractNode type, AbstractNode id, AbstractNode params) {return new FunctionDefNode(type,id,params);}
   public AbstractNode makeFunctionDefNodeNoBodyNoParams(AbstractNode type, AbstractNode id) {return new FunctionDefNode(type,id);}
   public AbstractNode makeReturnStatement(AbstractNode argument) {return new ReturnStatementNode(argument);}
   public AbstractNode makeFunctionCall(AbstractNode id, AbstractNode params) {return new FunctionCallNode(id, params);}
   public AbstractNode makeFunctionCallNoParams(AbstractNode id) {return new FunctionCallNode(id);}
   public AbstractNode makeIfStatementNode(AbstractNode test) {return new IfStatementNode(test);}
   public AbstractNode makeConditionNode (String operator, AbstractNode left, AbstractNode right) {return new ConditionNode(operator,left,right);}
:};
/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, TIMES, DIVIDE, MOD, EQUALS;
terminal            LEFT_PAREN, RIGHT_PAREN, LEFT_CURLY, RIGHT_CURLY, COMMA;
terminal            RETURN;
terminal            IS, NOT, OR, AND, GREATER, LESSER, GREATER_EQUALS, LESSER_EQUALS;
terminal            PROTOTYPE;
terminal            IF,ELSE;
terminal Integer    INTEGER;        // our scanner provides numbers as integers
terminal Float      DECIMAL;
terminal String     IDENTIFIER, IDENTIFIERVAL, IDENTIFIERADR;
terminal            INT_TYPE, DECIMAL_TYPE, VOID_TYPE;

non terminal AbstractNode CompilationUnit;
non terminal AbstractNode FieldDeclarations;
non terminal AbstractNode FieldDeclaration;
non terminal AbstractNode FunctionDeclarations;
non terminal AbstractNode FunctionDeclaration;
non terminal AbstractNode FunctionBodyDeclarations;
non terminal AbstractNode FunctionBodyDeclaration;
non terminal AbstractNode Params;
non terminal AbstractNode Param;
non terminal AbstractNode CallParams;
non terminal AbstractNode CallParam;
non terminal AbstractNode TypeDeclaration;
non terminal AbstractNode Assignment;
non terminal AbstractNode SelectiveStmt;
non terminal AbstractNode LogicalStmt;
non terminal AbstractNode Body;
non terminal AbstractNode AdditiveExpr;
non terminal AbstractNode MultiplicativeExpr;
non terminal AbstractNode UnaryExpr;
non terminal AbstractNode TypeName;
non terminal AbstractNode Identifier;
non terminal AbstractNode OnlyIdentifier;
non terminal AbstractNode Literal;
non terminal AbstractNode Decimal;
non terminal AbstractNode ReturnStmt;
non terminal AbstractNode ReturnType;
non terminal AbstractNode FunctionCall;
/* Precedences */
precedence left RETURN;
precedence left INT_TYPE, DECIMAL_TYPE, VOID_TYPE;
precedence left IDENTIFIER,IDENTIFIERVAL,IDENTIFIERADR;
precedence left INTEGER, DECIMAL;
precedence left AND, OR;
precedence left IS, NOT;
precedence left GREATER, LESSER, GREATER_EQUALS, LESSER_EQUALS;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence left LEFT_PAREN, RIGHT_PAREN;
precedence left IF, ELSE;
precedence left LEFT_CURLY, RIGHT_CURLY;
precedence left PROTOTYPE;
precedence left COMMA;

/* The grammar rules */

start with CompilationUnit;

CompilationUnit ::= Body:b
{:
    prog = new ProgramNode(b);
    prog.node.put("type", "Program");

    prog.adoptChildren(b);
    addAllNodesToJSON(prog,true);


     try (FileWriter file = new FileWriter("src/main/resources/ast.json")) {
                //We can write any JSONArray or JSONObject instance to the file
                file.write(allNodes.toJSONString());
                file.flush();

     } catch (IOException e) {
         e.printStackTrace();
     }
:};

Body                ::= FieldDeclarations:fds
                    {: RESULT = fds; :}
                    |  FunctionDeclarations:fds FieldDeclarations:fd
                    {: RESULT = fds.makeSibling(fd); :}
                    ;

FunctionDeclarations ::= FunctionDeclaration:fd
                    {: RESULT = fd; :}
                    | FunctionDeclarations:fds FunctionDeclaration:fd
                    {: RESULT = fds.makeSibling(fd); :}
                    ;

FunctionDeclaration ::= PROTOTYPE:p ReturnType:t OnlyIdentifier:id LEFT_PAREN Params:pas RIGHT_PAREN SEMI
                    {:  RESULT = makeFunctionDecNode(t,id,pas); :}
                    |   PROTOTYPE:p ReturnType:t OnlyIdentifier:id LEFT_PAREN RIGHT_PAREN SEMI
                    {:  RESULT = makeFunctionDecNodeNoParams(t,id); :}
                   ;

Params            ::= Param:pa
                   {: RESULT = pa;:}
                   | Params:pas COMMA Param:pa
                   {: RESULT = pas.makeSibling(pa); :}
                   ;

Param             ::= TypeName:t Identifier:id
                   {: RESULT = makeVariableDeclarationNoBody(t, id);:}
                   ;

CallParams        ::= CallParam:cp
                   {: RESULT = cp;:}
                   | CallParams:cps COMMA CallParam:cp
                   {: RESULT = cps.makeSibling(cp); :}
                   ;

CallParam         ::= AdditiveExpr:ae
                   {: RESULT = ae; :}
                   ;

FieldDeclarations ::= FieldDeclaration:fd
                  {: RESULT = fd; :}
                  |   FieldDeclarations:fds FieldDeclaration:fd
                  {: RESULT = fds.makeSibling(fd); :}
                  ;


FieldDeclaration ::= TypeDeclaration:tds
                 {: RESULT = tds;:}
                 |   AdditiveExpr:ae SEMI
                 {: RESULT = ae; :}
                 | Assignment:as
                 {: RESULT = as; :}
                 | FunctionCall:fcs
                 {: RESULT = fcs;  :}
                 | SelectiveStmt:ss
                 {: RESULT = ss; :}
                 ;

SelectiveStmt   ::= IF LEFT_PAREN LogicalStmt:ls RIGHT_PAREN LEFT_CURLY FieldDeclarations:fds RIGHT_CURLY
                  {: RESULT = makeIfStatementNode(ls); :}
                  | ELSE IF LEFT_PAREN LogicalStmt:ls RIGHT_PAREN LEFT_CURLY FieldDeclarations:fds RIGHT_CURLY
                  {: RESULT = makeIfStatementNode(ls);:}
                  | IF LEFT_PAREN LogicalStmt:ls RIGHT_PAREN LEFT_CURLY FieldDeclarations:fds RIGHT_CURLY ELSE LEFT_CURLY FieldDeclarations:fds2 RIGHT_CURLY
                  {:  :}
                   ;


LogicalStmt     ::= LogicalStmt:s1 AND AdditiveExpr:a1
                    {: RESULT = makeConditionNode("AND", a1, s1); :}
                  | LogicalStmt:s1 OR AdditiveExpr:a1
                    {: RESULT = makeConditionNode("OR", a1, s1); :}
                  | AdditiveExpr:a1
                    {: RESULT = a1; :}
                    ;


FunctionCall     ::= OnlyIdentifier:id LEFT_PAREN CallParams:cps RIGHT_PAREN SEMI
                 {:  RESULT = makeFunctionCall(id,cps);:}
                 |   OnlyIdentifier:id LEFT_PAREN RIGHT_PAREN SEMI
                 {:  RESULT = makeFunctionCallNoParams(id);:}
                 ;

FunctionBodyDeclarations ::= FunctionBodyDeclaration:fd
                  {: RESULT = fd; :}
                  |   FunctionBodyDeclarations:fds FunctionBodyDeclaration:fd
                  {: RESULT = fds.makeSibling(fd); :}
                  ;


FunctionBodyDeclaration ::= TypeDeclaration:td
                 {: RESULT = td;:}
                 |  AdditiveExpr:ae
                 {: RESULT = ae; :}
                 | Assignment:as
                 {: RESULT = as; :}
                 | ReturnStmt:rs
                 {: RESULT = rs; :}
                 ;

TypeDeclaration  ::= ReturnType:tn OnlyIdentifier:id SEMI
                 {: RESULT = makeVariableDeclarationNoBody(tn,id); :}
                 |   ReturnType:tn OnlyIdentifier:id EQUALS AdditiveExpr:e SEMI
                 {: RESULT = makeNode(tn,id,e); :}
                 |   ReturnType:t OnlyIdentifier:id LEFT_PAREN Params:pas RIGHT_PAREN LEFT_CURLY FunctionBodyDeclarations:fds RIGHT_CURLY
                 {: RESULT = makeFunctionDefNode(t,id,pas,fds); :}
                 |   ReturnType:t OnlyIdentifier:id LEFT_PAREN Params:pas RIGHT_PAREN LEFT_CURLY RIGHT_CURLY
                 {: RESULT = makeFunctionDefNodeNoBody(t,id,pas); :}
                 |   ReturnType:t OnlyIdentifier:id LEFT_PAREN  RIGHT_PAREN LEFT_CURLY FunctionBodyDeclarations:fds RIGHT_CURLY
                 {: RESULT = makeFunctionDefNodeNoBody(t,id,fds); :}
                 |   ReturnType:t OnlyIdentifier:id LEFT_PAREN RIGHT_PAREN LEFT_CURLY RIGHT_CURLY
                 {: RESULT = makeFunctionDefNodeNoBodyNoParams(t,id); :}
                 ;




Assignment      ::= Identifier:id EQUALS AdditiveExpr:e SEMI
                {: RESULT = makeAssignmentNode(id,e); :}
                ;



AdditiveExpr    ::= AdditiveExpr:e1 PLUS MultiplicativeExpr:e2
                {: RESULT = makeNode(e1, e2, "+"); :}
                |   AdditiveExpr:e1 MINUS MultiplicativeExpr:e2
                {: RESULT = makeNode(e1, e2, "-"); :}
                | AdditiveExpr:s1 LESSER MultiplicativeExpr:a1
                {: RESULT = makeNode( s1,a1, "LESSER");:}
                | AdditiveExpr:s1 LESSER_EQUALS MultiplicativeExpr:a1
                {: RESULT = makeNode( s1,a1, "LESSER_EQUALS"); :}
                | AdditiveExpr:s1 GREATER MultiplicativeExpr:a1
                {: RESULT = makeNode(s1,a1, "GREATER"); :}
                | AdditiveExpr:s1 GREATER_EQUALS MultiplicativeExpr:a1
                {: RESULT = makeNode( s1, a1, "GREATER_EQUALS"); :}
                | AdditiveExpr:s1 IS NOT MultiplicativeExpr:a1
                {: RESULT = makeNode( s1,a1, "IS_NOT");:}
                | AdditiveExpr:s1 IS MultiplicativeExpr:a1
                {: RESULT = makeNode(s1, a1,"IS");:}
                |   MultiplicativeExpr:e2
                {: RESULT = e2; :}
                ;


MultiplicativeExpr ::= MultiplicativeExpr:e1 TIMES UnaryExpr:e2
                {: RESULT = makeNode(e1, e2, "*"); :}
                |   MultiplicativeExpr:e1 DIVIDE UnaryExpr:e2
                {: RESULT = makeNode(e1, e2, "/"); :}
                |   MultiplicativeExpr:e1 MOD UnaryExpr:e2
                {: RESULT = makeNode(e1, e2, "%"); :}
                |   UnaryExpr:e2
                {: RESULT = e2; :}
                ;


UnaryExpr       ::= Literal:n           /* MINUS expr:e er blevet fjernet. Tror vi kan tilføje den igen her. */
                {: RESULT = n; :}
                | Decimal:n
                {: RESULT = n; :}
                | Identifier:id
                {: RESULT = id; :}
                ;

OnlyIdentifier  ::=IDENTIFIER:id
                {: RESULT = makeIdentifierNode(id,""); :}
                ;

Identifier      ::= IDENTIFIERADR:id
                {: RESULT = makeIdentifierNode(id, "adr"); :}
                | IDENTIFIERVAL:id
                {: RESULT = makeIdentifierNode(id, "val"); :}
                ;


TypeName        ::= INT_TYPE:type
                {: RESULT = makeTypeNode("int"); :}
                |  DECIMAL_TYPE:type
                {: RESULT = makeTypeNode("decimal"); :}
                ;

ReturnType      ::= INT_TYPE:type
                {: RESULT = makeTypeNode("int");:}
                | DECIMAL_TYPE:type
                {: RESULT = makeTypeNode("decimal");:}
                | VOID_TYPE:type
                {: RESULT = makeTypeNode("void");:}
                ;


Literal         ::= INTEGER:n
                {: RESULT = makeNode(n); :}
                ;


Decimal         ::= DECIMAL:n
                {: RESULT = makeNode(n); :}
                ;

ReturnStmt      ::= RETURN AdditiveExpr:ae SEMI
                {:  RESULT = makeReturnStatement(ae); :}
                ;


/* Et hus fuld af muuuuuuuuuuuuuuuuuuuuuuuuuus */