import java_cup.runtime.*;
import lab7.*;
import java.io.FileWriter;
import java.io.IOException;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

action code {:

   public JSONArray allNodes = new JSONArray();
   public JSONArray allNodesUnderProg = new JSONArray();
   public JSONArray expressions = new JSONArray();

      public AbstractNode addAllNodesToJSON (AbstractNode n) {
          if(n.getChild() != null) {
              n.node.put("Body", AddAllChild(n.getChild(),new JSONArray()));
              allNodes.add(n.node);
          }
          return null;
      }

      public JSONArray AddAllChild (AbstractNode n, JSONArray array) {
          array.add(n.node);
          if(n.getSib() != null) {
              AddAllChild(n.getSib(),array);
          }
          if(n.getChild() != null) addAllNodesToJSON(n.getChild());
          return array;
      }
   class BinaryOPNode extends AbstractNode {
         AbstractNode number1;
         AbstractNode number2;
         String operator;

         public BinaryOPNode (AbstractNode number1, AbstractNode number2, String operator) {
            this.number1 = number1;
            this.number2 = number2;
            this.operator = operator;


            node.put("left", number1.node);
            node.put("right", number2.node);
            node.put("type", "BinaryExpression");
            node.put("operator", operator);

         }
         public String getName() {return number1 + " " + operator + " " + number2;}
   }

   class IdentifierNode extends AbstractNode {
        String id;

        public IdentifierNode (String id) {
            this.id = id;
            node.put("type", "Identifier");
            node.put("id", id);
        }
        public String getValue() {return id;}
   }

   class TypeNode extends AbstractNode {
        String type;

        public TypeNode (String type) {
            this.type = type;
            node.put("type", "Type");
            node.put("dataType", type);
        }

        public String getValue() {return type;}
   }

   class IntegerNode extends AbstractNode {
        int value;
        public IntegerNode(int value) {
            this.value = value;
            node.put("type", "Literal");
            node.put("value", value);

        }

        public int getValue() {return value;}
   }

      class FloatNode extends AbstractNode {
           float value;
           public FloatNode(float value) {
               this.value = value;
               node.put("type", "Decimal");
               node.put("value", value);

           }

           public float getValue() {return value;}
      }

   class SingleNode extends AbstractNode {
         String name;


         public SingleNode(String name) {
            this.name = name;
         }
         public String getName() {return name;}
   }

   public AbstractNode makeNode(AbstractNode number1, AbstractNode number2, String operator) {return new BinaryOPNode(number1,number2, operator);}
   public AbstractNode makeNode(int value) {return new IntegerNode(value);}
   public AbstractNode makeNode(float value) {return new FloatNode(value);}
   public AbstractNode makeNode(String name) {return new SingleNode(name);}
   public AbstractNode makeTypeNode(String type) {return new TypeNode(type);}
   public AbstractNode makeIdentifierNode(String id) {return new IdentifierNode(id);}
:};
/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, TIMES, DIVIDE, MOD, EQUALS;
terminal Integer    INTEGER;        // our scanner provides numbers as integers
terminal Float      DECIMAL;
terminal String     IDENTIFIER;
terminal            INT_TYPE, DECIMAL_TYPE;

non terminal AbstractNode CompilationUnit;
non terminal AbstractNode expr_list;
non terminal AbstractNode expr;      // used to store evaluated subexpressions
non terminal AbstractNode TypeDeclarations;
non terminal AbstractNode TypeDeclaration;
non terminal AbstractNode TypeName;
non terminal AbstractNode Identifier;
/* Precedences */
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
/* The grammar rules */

start with CompilationUnit;

CompilationUnit ::= TypeDeclarations:td
{:

    AbstractNode prog = makeNode("prog");
    System.out.println(td);
    prog.node.put("type", "Program");

    prog.adoptChildren(td);
    addAllNodesToJSON(prog);


     try (FileWriter file = new FileWriter("ast.json")) {
                //We can write any JSONArray or JSONObject instance to the file
                file.write(allNodes.toJSONString());
                file.flush();

     } catch (IOException e) {
         e.printStackTrace();
     }
:};

TypeDeclarations ::= TypeDeclaration: td
                 {:  RESULT = td; :}
                 |   TypeDeclarations:tds TypeDeclaration:td
                 {:  RESULT = tds.makeSibling(td); :}
                 ;

TypeDeclaration ::= TypeName:tn Identifier:id SEMI
                {: RESULT = tn.makeSibling(id); :}
                |   TypeName:tn Identifier:id EQUALS expr_list:el
                {: RESULT = tn.makeSibling(id).adoptChildren(el); :}
                ;

expr_list ::= expr_list:el expr:e SEMI {: RESULT = el.makeSibling(e); :}
            | expr:e SEMI              {: RESULT = e; :}
	    	;
	    
expr      ::= expr:e1 PLUS  expr:e2
            {: RESULT = makeNode(e1, e2, "+"); :}
	    	| expr:e1 MINUS expr:e2
	    	{: RESULT = makeNode(e1, e2, "-"); :}
	    	| expr:e1 TIMES expr:e2
	    	{: RESULT = makeNode(e1, e2, "*"); :}
	    	| expr:e1 DIVIDE expr:e2
            {: RESULT = makeNode(e1, e2, "/"); :}
            | expr:e1 MOD expr:e2
            {: RESULT = makeNode(e1, e2, "%"); :}
	    	| INTEGER:n
	    	{: RESULT = makeNode(n); :}
	    	| DECIMAL:n
	    	{: RESULT = makeNode(n); :}
	    	| MINUS expr:e
            ;

Identifier  ::= IDENTIFIER:id
            {: RESULT = makeIdentifierNode(id); :}
            ;

TypeName    ::= INT_TYPE:type
            {: RESULT = makeTypeNode("int"); :}
            |  DECIMAL_TYPE:type
            {: RESULT = makeTypeNode("decimal"); :}
            ;